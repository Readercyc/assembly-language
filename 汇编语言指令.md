# 汇编语言指令

## 基本指令

### MOV 传送指令
格式：MOV DST SRC  
操作：(DST)<-(SRC) ,将源操作数送到目的操作数

其中，DST是目的操作时，SRC  是源操作数

P.S
1. 源操作数与目的操作数的长度必须明确且一致，即同时为8位/16位
2. 目的操作数与源操作数不能同为存储器，不允许在两个存储单元之间直接传送数据
3. 目的操作数不能为`CS`或`IP`，因为CS:IP指向的是当前要执行的指令所在的地址
4. 目的操作数不可以是立即数

### XLAT(translate） 换码指令
格式：XLAT
操作：AL<-（BX+AL)

把BX+AL的值作为有效地址，取出其中的一个字节送AL

### XCHG 交换指令
格式：XCHG OPR1,OPR2
操作：(OPR1)<- ->(OPR2)。其中OPR1、OPR2为操作数

把两个操作数位置互换


---

## 堆栈操作指令

目的操作数地址由SS:SP指定，指令中无需给出
SP总是指向栈顶，SP的初值为栈底
当 SP = 0 栈满
当 SP = MAX 时 栈空

### PUSH
格式：PUSH OPS
1. ([SP])<-(OPD)0-7 SP-1
2. ([SP])<-(OPD)15-8 SP-1
功能：将寄存器、段寄存器或存储器中的一个字数据压入堆栈，堆栈指针-2

### POP
格式：POP OPD
操作:
1. ([SP])->(OPD)0-7 SP+1
2. ([SP])->(OPD)15-8 SP+1
功能：将栈顶元素弹出送至某一寄存器、段寄存器或存储器，堆栈指针+2

```
实现swap XCHG
PUSH AX
PUSH BX
POP AX
POP BX
```

## 标志寄存器传送指令

### 标志送AH指令LAHF
格式：LAHF
功能：将标志寄存器的低8位送入AH寄存器。
即（FLAGS)7-0 -> AH。该指令的执行对标志位无影响
应用：保护低8位，送入AH

### AH送标志指令SAHF
格式：LAHF
功能：将AH寄存器送入标志寄存器的低8位。(保护低8位，送入AH)
即（FLAGS)7-0 <- AH。
SAHF为LAHF的逆过程
应用：批量处理标志寄存器的数据

### 标志寄存器进栈指令PUSHF
格式：PUSHF
功能：将标志寄存器的全部内容压入栈

### 标志寄存器出栈指令POPF
格式：POPF
功能：将栈顶内容弹出送入标志寄存器中。即↑(SP) → FLAGS
应用：修改标志寄存器的值

---

## 地址传送指令

### 传送偏移地址指令LEA

格式：LEA OPD,OPS
功能：按原地址的寻址方式计算偏移地址，将偏移地址送入制定寄存器中（将源操作数的有效地址送到目的操作数中),其中源操作数是mem，目的操作数是一个16位的reg（寄存器)
```
MOV BX,0100H ; //(BX) = 0100H
MOV SI,0210H ; //(SI) = 0210H
LEA BX,1234[BX+SI] ; //(BX) = 1544H，基址变址相对寻址
//LEA传地址，MOV传数据
```
### 传送偏移地址及数据段首地址指令LDS
格式：LDS OPD,OPS
功能：将源操作数SRC所指向的内存单元中2个字送到指定的REG和DS（一个字 = 8位）

### 传送偏移地址及附加数据段首地址指令LES
格式：LES OPD,OPS
功能：将源操作数SRC所指向的内存单元中2个字送到指定的REG和ES（一个字 = 8位）
**基本与LDS相同**

---

## 输入输出指令

### 输入指令 IN
语句格式： IN AL,PORT
功能：（PORT) -> AL，从PORT读一个字节送给AL（8位）
语句格式： IN AX,PORT
功能：（PORT) -> AX，从PORT读一个字送给AX（16位）
语句格式： IN AX,DX
功能：（DX) -> AL，从DX读一个字节送给AL（8位）
语句格式： IN AX,DX
功能：（DX) -> AX，从DX读一个字送给AX（16位）

### 输出指令 OUT 

语句格式： OUT AL,PORT
功能：（PORT) <- AL，从AL读一个字节送给PORT（8位）
语句格式： OUT AX,PORT
功能：（PORT) <- AX，从AX读一个字送给PORT（16位）
语句格式： OUT AX,DX
功能：（DX) <- AL，从AL读一个字节送给DX（8位）
语句格式： OUT AX,DX
功能：（DX) <- AX，从AX读一个字送给DX（16位）

---
##算术运算类指令


### 加1指令（i++) INC

### 不带进位的加指令 ADD

格式：ADD OPD,OPS
功能: 将OPS + OPD 并送入 OPD

- 要求长度一致
- 源操作数可以使reg，mem，data，目的操作数是reg。mem
- 立即数比可以做目的操作数
- 两个数不能同时为mem
- 会影响标志位
```
例：
    11100011
+   10100000
-------------
1<- 10000011  
AL = 83H ,
AF = 0,CF = 1, OF = 0,PF = 0 ,SF = 1,ZF = 0;
(AF 与 SF同号为正，异号为负数）

习题：
AX = 790EH BX = 8831H
   0111 1001 0000 1110
 + 1000 1000 0011 0001
----------------------
1<-0000 0001 0011 1111
AX = 013FH
AF = 0,CF = 1, OF = 0,PF = 1 ,SF = 0,ZF = 0;
```

### 带进位的加指令 ADC

指令的汇编格式：ADD dst,src
指令的基本功能：(dst)<-(src)+(dst)+CF
指令支持的寻址方式：他们两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，源操作数和目地操作数必须有一个寄存器寻址方式。
指令对标志位的影响：SF=1 加法结果为负数

各标志位的意义

- SF=0 加法结果为正数
- ZF=1 加法结果为零
- ZF=0 加法结果不为零
- CF=1 最高有效位向高位有进位
- CF=0 最低有效位相高位无进位
- OF=1 两个同符号数相加，结果符号与其相反，
- OF=0 两个同符号数相加，或同符号相加，结果符号与其相同

### 减法指令 SUB (subtract)
指令的汇编格式：SUB dst,src
指令的基本功能：(dst)<-(dst)-(src)
指令支持的寻址方式：他们两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，源操作数和目地操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

- SF=1 减法结果为负数（符号位为1）
- SF=0 减法结果为正数（符号位为0）
- ZF=1 减法结果为零
- ZF=0 减法结果不为零
- CF=1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）
- CF=0 二进制减法运算中最高有效为向高位无借位（被减数〉=减数，够减的情况）
- OF=1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。
- OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。

### 带借位减法指令 SBB (subtract with borrow)
指令的汇编格式：SBB dst,src
指令的基本功能：(dst)<-(dst)-(src)-CF
指令支持的寻址方式：他们两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，源操作数和目地操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

- SF=1 减法结果为负数（符号位为1）
- SF=0 减法结果为正数（符号位为0）
- ZF=1 减法结果为零
- ZF=0 减法结果不为零
- CF=1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）
- CF=0 二进制减法运算中最高有效为向高位无借位（被减数〉=减数，够减的情况）
- OF=1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。
- OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。

### 减1指令 DEC (decrement)
指令的汇编格式：DEC opr
指令的基本功能：(opr)<-(opr)-1
指令支持的寻址方式：可以使用除立即数方式外的任何寻址方式。
指令对标志位的影响：

 - SF=1 减法结果为负数（符号位为1）
 - SF=0 减法结果为正数（符号位为0）
 - ZF=1 减法结果为零
 - ZF=0 减法结果不为零
 - OF=1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。
 - OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。

### 比较指令 CMP (compare)
指令的汇编格式：CMP opr1,opr2
指令的基本功能：(opr1)-(opr2),根据相减结果设置条件码，但不回送结果。
指令支持的寻址方式：他们两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，源操作数和目地操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

 - SF=1 减法结果为负数（符号位为1）
 - SF=0 减法结果为正数（符号位为0）
 - ZF=1 减法结果为零
 - ZF=0 减法结果不为零
 - CF=1 二进制减法运算中,最高有效位向高位有借位（被减数小于减数，不够减的情况）
 - CF=0 二进制减法运算中最高有效为向高位无借位（被减数〉=减数，够减的情况）
 - OF=1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。
 - OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。

### 求补指令 NEG (negate)
指令的汇编格式：NEG opr
指令的基本功能：(opr)<- -(opr)
指令支持的寻址方式：可以使用除立即数方式外的任何寻址方式。
指令对标志位的影响：

 - CF=1 　不为0的操作数求补时
 - CF=0 　为0的操作数求补时
 - OF=1 操作数为-128（字节运算）或操作数为-32768（字运算）
 - OF=0 当求补运算的操作数不为－128（字节）或－32768（字）时三、乘法指令

### 无符号乘法指令 NUL (unsigned multiple)
有符号乘法指令 IMUL(signed muliple)
指令的汇编格式：NUL src IMUL src
指令的基本功能：(AX)<-(AL)* (src) (DX,AX)<-(AX) * (src)
指令支持的寻址方式：src可以使用除立即数方式以外的任一种寻址方式。
指令对标志位的影响：乘法指令只影响标志位CF和OF，其他条件码位无定义。
MUL指令的条件码设置为：

- CF OF=0 0 
    - 乘积的高一半为0（字节操的（AH）或字操作的（DX））
- CF OF=1 1 
    - 乘积的高一半不为0

IMUL指令的条件码设置为：

 - CF OF=0 0 
    - 乘积的高一半为低一半的符号扩展

- CF OF=1 1 
    - 其他情况

指令的特殊要求：MUL和IMUL指令的区别仅在于操作数是无符号还是带符号数，它们的共同点是，指令中只给出源操作数src，目的操作数是隐含的，它只能是累加器（字运算为AX，字节运算为AL）。隐含的乘积寄存器是AX或DX（高位）和AX（低位）。

## 符号扩展指令
### 节扩展为字 CBW (convert byte to word)
指令的汇编格式：CBW
指令的基本功能：(AH)=00H 当(AL)的最高有效位为0时
(AH)=FFH 当(AL)的最高有效位为1时
指令对标志位的影响：不影响标志位
指令的特殊要求：这是条无操作数的指令，进行符号扩展的操作数必须存放在AL寄存器 AX寄存器中。
### 字扩展为双字 CWD (convert word to double word)
指令的汇编格式：CWD
指令的基本功能：(DX)=0000H 当(AX)的最高有效位为0时
(DX)=FFFFH 当(AX)的最高有效位为1时
指令对标志位的影响：不影响标志位
指令的特殊要求：这是条无操作数的指令，进行符号扩展的操作数必须存放在AL寄存器或AX寄存器中。

## 除法指令
### 无符号数除法 DIV (unsigned divide)
带符号数除法 IDIV (singed divide)
指令的汇编格式：DIV src IDIV src
指令的基本功能：字操作
(AL)<-(AX)/src的商 (AH)<-(AX)/src的余数
字节操作
(AX)<-(DX,AX)/src的商 (DX)<-(DX,AX)/src的余数
指令支持的寻址方式：src作为除数，可用除立即数以外的任一种寻址方式来取得。
指令对标志位的影响：不影响条件码。
指令的特殊要求：除法指令要求字操作时，被除数必须为32位，除数是16位，商和余数是16位的；字节操作时，被除数必须为16位，除数是8位，得到的商和余数是8位的。

## 十进制调整指令


### 逻辑运算
指令的格式：AND dst,src
指令的基本功能：(dst)<-(dst)与(src)
指令支持的寻址方式：两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，源操作数和目地操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

 - 指令执行后 CF 和 OF 置零，AF无定义。
 - SF=1 指令执行后的结果为负数（符号位为1）
 - SF=0 指令执行后的结果为正数（符号位为0）
 - ZF=1 指令执行后的结果为零
 - ZF=0 指令执行后的结果不为零
 - PF=1 结果操作数中1的个数为偶数时置1
 - PF=0 结果操作数中1的个数为奇数时置0

### 逻辑或 OR (logic or)
指令的汇编格式：OR dst，src
指令的基本功能：(dst)<-(dst)或(src)
指令支持的寻址方式：两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，原操作数和目的操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

 - 令执行后 CF 和 OF 置零，AF无定义。
 - SF=1 指令执行后的结果为负数（符号位为1）
 - SF=0 指令执行后的结果为正数（符号位为0）
 - ZF=1 指令执行后的结果为零
 - ZF=0 指令执行后的结果不为零
 - PF=1 结果操作数中1的个数为偶数时置1
 - PF=0 结果操作数中1的个数为奇数时置0

### 逻辑非 NOT (logic not)
指令的汇编格式：NOT orc
指令的基本功能：(dst)<-(opr)
指令支持的寻址方式：除立即数寻址方式以外的其余寻址方式
指令对标志位的影响：对标志位无影响

### 异或 XOR (exclusice or)
指令的汇编格式：XOR dst,src
指令的基本功能：(dst)<-(dst)异或(src)
指令支持的寻址方式：两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，原操作数和目的操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

 - 令执行后 CF 和 OF 置零，AF无定义。
 - SF=1 指令执行后的结果为负数（符号位为1）
 - SF=0 指令执行后的结果为正数（符号位为0）
 - ZF=1 指令执行后的结果为零
 - ZF=0 指令执行后的结果不为零
 - PF=1 结果操作数中1的个数为偶数时置1
 - PF=0 结果操作数中1的个数为奇数时置0

### 测试指令 TEST
指令的汇编格式：TEST opr1,opr2
指令的基本功能：(opr1)与(opr2)
指令支持的寻址方式：两个操作数不能同时为存储器寻址，即为除源操作数为立即数的情况外，源操作数和目的操作数必须有一个寄存器寻址方式。
指令对标志位的影响：

 - 令执行后 CF 和 OF 置零，AF无定义。
 - SF=1 指令执行后的结果为负数（符号位为1）
 - SF=0 指令执行后的结果为正数（符号位为0）
 - ZF=1 指令执行后的结果为零
 - ZF=0 指令执行后的结果不为零
 - PF=1 结果操作数中1的个数为偶数时置1
 - PF=0 结果操作数中1的个数为奇数时置0

## 移位指令

###逻辑左移 SHL (shift logical left)
指令的汇编格式：SHL dst,cnt
指令的基本功能：SHL指令向左逐位移动cnt次，每次逐位移动后，最低位用0来补充，最高位移入CF。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移位次数（或位数）cnt=1时，1可以直接写在指令中，cnt〉1时，cnt必须放入CL寄存器中。
指令对标志位的影响：

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置
### 逻辑右移 SHR (shift logical right)
指令的汇编格式：SHR dst,cnt
指令的基本功能：SHR指令向右逐位移动cnt次，每次逐位移动后，最高位用0来补充，最低位移入CF。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移位次数（或位数）cnt=1时，1可以直接写在指令中，cnt〉1时，cnt必须放入CL寄存器中。

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

### 算术左移 SAL (shift arithmetic left)
指令的汇编格式：SAL dst cnt
指令的基本功能：SAL指令向左逐位移动cnt次，每次逐位移动后，最低位用0来补充，最高位移入CF。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移位次数（或位数）cnt=1时，1可以直接写在指令中，cnt〉1时，cnt必须放入CL寄存器中。
指令对标志位的影响：

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

### 算术右移 SAR (shift arithmetic right)
指令的汇编格式：SAR dst,cnt
指令的基本功能：SAR指令向右逐位移动cnt次，每次逐位移动后，最高位用符号位来补充，最低位移入CF。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式 。移位次数（或位数）cnt=1时，1可以直接写在指令中，cnt〉1时，cnt必须放入CL寄存器中。
指令对标志位的影响：

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

### 循环左移 ROL (rotate left)
指令的汇编格式：ROL dst,cnt
指令的基本功能：ROL 对由dst指定的寄存器或存储器操作数左移循环移动cnt所指定的次数，每左移一次，把最高位同时移入CF和操作数最低位。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移动次数（或位数）cnt=1时，1可以直接写在指令中，cnt〉1时，cnt必须放入CL寄存器中。

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

### 循环右移 ROR (rotate right)
指令的汇编格式：ROR dst,cnt
指令的基本功能：ROR 对由dst指定的寄存器或存储器操作数右移循环移动cnt所指定的次数，每右移一次，把最低位同时移入CF和操作数最高位。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移动次数（或位数）cnt=1时，1可以直接写在指令中，cnt>1时，cnt必须放入CL寄存器中。

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

### 带进位的循环左移 RCL (rotate left through carry)
指令的汇编格式：RCL dst,cnt
指令的基本功能：RCL 对由dst指定的寄存器或存储器操作数，连同进位标志CF左循环移动，m所指定的次数，每左移一次，把操作数的最高位移入CF，而CF中原有内容移入操作数的最低位。
指定支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移动次数（或位数）cnt=1时，1可以直接写在指令中，cnt〉1时，cnt必须放入CL寄存器中。
指令对标志位的影响：

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

36、带进位的循环右移 RCR (rotate right through carry)
指令的汇编格式：RCR dst，cnt
指令的基本功能：RCR 对由dst指定的寄存器或存储器操作数，连同进位标志CF右循环移动，m所指定的次数，每右移一次，把操作数的最高低位移入CF，而CF中原有内容移入操作数的最高位。
指令支持的寻址方式：目的操作数dst可以是除立即数外的任何寻址方式。移动次数（或位数）cnt=1时，1可以直接写入指令中，cnt〉1时，cnt必须放入CL寄存器中。

指令对标志位的影响：

- CF=移入的数值
- OF=1 当cnt=1时，移动后最高位的值发生变化。
- OF=0 当cnt=1时，移动时最高位的值未发生变化。
- SF、ZF、PF根据移动后的结果设置

## 串处理指令

### 设置方向标志指令
### DF置零 CLD (clear direction flag)
### DF置一 STD (set direction flag)
指令的汇编格式：CLD STD
指令的基本功能：CLD DF=0 STD DF=1


### 串传送 MOVSB / MOVSW (move string byte/word)
指令的汇编格式：MOVSB MOVSW
指令的基本功能：(ES:DI)<-(DS:SI)
(SI)<-(SI)+/-1(字节)或+/-2(字)
(DI)<-(DI)+/-1(字节)或+/-2(字)
指令对条件码的影响：不影响条件码。
指令的特殊要求：源串必须在数据段中，目的串必须在附加段中，串处理指令隐含的寻址方式是SI和DI寄存器的间接寻址方式。源串允许使用段跨越前缀来指定段。

### 存串 STOSB / STOSW (stroe from string byte/word)
指令的汇编格式：STOSB
STOSW
指令的基本功能：(ES:DI)<-(AL)或(AX)
(DI)<-(DI)+/-1(字节)或+/-2(字)
指令对条件码的影响：不影响条件码。
指令的特殊要求：源串必须在数据段中，目的串必须在附加段中，串处理指令隐含的寻址方式是SI和DI寄存器的间接寻址方式。源串允许使用段跨越前缀来指定段。

### 取串LODSB / LODSW (load from string byte/word)
指令的汇编格式：LODSB
LODSW
指令的基本功能：(AL)或(AX)<-(DS:SI)
(SI)<-(SI)+/-1(字节)或+/-2(字)
指令对条件码的影响：不影响条件码。
指令的特殊要求：源串必须在数据段中，目的串必须在附加段中，串处理指令隐含的寻址方式是SI和DI寄存器的间接寻址方式。源串允许使用段跨越前缀来指定段。

### 串比较 CMPSB / CMPSW (compare string byte/word)
指令的汇编格式：CMPSB
CMPSW
指令的基本功能：(DS:SI)-(ES:DI) 根据比较结果设置条件码
(SI)<-(SI)+/-1(字节)或+/-2(字)
(DI)<-(DI)+/-1(字节)或+/-2(字)
指令对条件码的影响：

- SF=1 减法结果为负数（符号位为1）
- SF=0 减法结果为正数（符号位为0）
- ZF=1 减法结果为零
- ZF=0 减法结果不为零
- CF=1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）
- CF=0 二进制减法运算中最高有效为向高位无借位（被减数〉=减数，够减的情况）
- OF=1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。
- OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。

### 串扫描 SCASB / SCASW (scan string byte / word)
指令的格式：SCASB
SCASW
指令的基本功能：(AL)<-(ES:DI)或(AX)<-(ES:DI) 根据扫描比较的结果设置条件码。
(DI)<-(DI)+/-1(字节)或+/-2(字)
指令对条件码的影响：

- SF=1 减法结果为负数（符号位为1）
- SF=0 减法结果为正数（符号位为0）
- ZF=1 减法结果为零
- ZF=0 减法结果不为零
- CF=1 二进制减法运算中最高有效位向高位有借位（被减数小于减数，不够减的情况）
- CF=0 二进制减法运算中最高有效为向高位无借位（被减数〉=减数，够减的情况）
- OF=1 两数符号相反（正数-负数，或负数-正数），而结果符号与减数相同。
- OF=0 同符号数相减时，或不同符号数相减，其结果符号与减数不同。


### 重复执行串 REP 
指令的汇编格式：REP (CX)=重复次数
指令的基本功能：
① (CX)=0时，串指令执行完毕，否则执行② ~ ④
② (CX)←(CX)－1
③ 执行串指令（MOVS或STOS）
④ 重复执行①
### 相等/为零时重复执行串指令 REPE/REPZ
指令的汇编格式：REPE / REPZ (CX)=比较/扫描的次数
指令的基本功能：
① (CX)=0或ZF=0时，结束执行串指令，否则继续② ~ ④
② (CX)←(CX)－1
③ 执行串指令（CMPS或SCAS）
④ 重复执行①
### 不等/不为零时重复执行串指令 REPNE / PEPNZ
指令的汇编格式：REPNE / PEPNZ (CX)=比较/扫描的次数
指令的基本功能：
① (CX)=0或ZF=1，结束执行串指令，否则继续② ~ ④
② (CX)←(CX)－1
③ 执行串指令（CMPS或SCAS）
④ 重复执行①


##无条件转移指令
### 短转移 JMP SHORT label (short jump)
指令的汇编格式：JMP SHORT label
指令的基本功能：(IP)<-当前(IP)+8位位移量 8位位移量是汇编程序在汇编源程序时，根据目标地址和当前IP之间的距离自动生成的。
指令对条件码的影响：对标志位无影响。
### 近转移 JMP NEAR PTR label (near jump)
指令的汇编格式：直接转移 JMP label (direct jump)
寄存器间接转移 JMP reg (register indirect jump)
存储器间接转移 JMP WORD PTR OPR (memory indirect jump)
指令的基本功能：JMP label (IP) <- OFFSET label = (IP)当前＋16位位移量
JMP reg (IP) <- (reg)
JMP WORD PTR OPR (IP) <- (PA+1,PA)
指令支持的寻址方式：指令中的转向地址可以是直接寻址方式、寄存器寻址方式、寄存器间接寻址方式和存储器寻址方式。
指令对条件码的影响：对标志位无影响。
### 远转移 JMP FAR PTR label (for jump)
指令的汇编格式：JMP FAR PTR label
指令的基本功能：(IP)<-label的段内偏移地址 (CS)<-label所在段的段地址
指令支持的寻址方式：远转移的目的地址可以使用除立即寻址方式外的任何寻址方式来表示。指令对条件码的影响：对标志位无影响。

## 条件转移指令
指令的汇编格式及功能
根据条件码的值转移：
### JZ(JE) 
OPR ZF=1
ZF=0（运算结果为0，ZF就置1）
### JNZ(JNE) 
OPR ZF=0
###  JS 
OPR SF=1
SF=0（二进制最高位是什么,SF就是什么，如最高位为1则SF=1）
###  JNS 
OPR SF=0
###  JO 
OPR OF=1
OF=1 (两个负数相加变成正数，溢出） 
###  JNO 
OPR OF=0
### JP 
OPR PF=1
PF=0 (反映结果“1”的个数，奇数☞0 偶数个☞1） 
### JNP 
OPR PF=0 
### JC 
OPR CF=1
CF=1（最高位有进位或借位就置1） 
### JNC 
OPR CF=0

## 比较两个无符号数，根据比较的结果转移

### JB(JNAE,JC) 
OPR CF=1 被减数小于减数则转移
### JNB(JAE,JNC) 
OPR CF=0 被减数大于或等于减数则转移
### JBE(JNA)
OPR CF或ZF=1 被减数小于或等于减数则转移
### JNBE(JA) 
OPR CF或ZF=0 被减数大于减数则转移
## 比较两个带符号数，根据比较结果转移
### JL/JNGE 
OPR SF异或OF=1 被减数小于减数则转移 
### JNL/JGE 
SF异或OF=0 被减数不小于减数则转移
### JLE/JNE 
(SF异或OF)与ZF=1 被减数不大于减数则转移
### JNLE/JG 
(SF异或OF)与ZF=0 被减数大于减数则转移

## 根据CX寄存器的值转移
### JCXZ (CX)=0 CX内容为零则转移
指令的特殊要求：所有条件转移指令都是短转移指令，转移的目标地址必须在当前IP地址的-128至+127字节范围之内，因此条件转移指令是2字节指令。

## 循环指令
### 循环 LOOP (loop)
指令的汇编格式：LOOP label
指令的基本功能：① (CX)←(CX)－1 ② 若(CX)≠0，则(IP)←(IP)当前＋位移量，否则循环结束。
指令的特殊要求：循环指令都是短转移格式的指令，也就是说，位移量是用8位带符号数来表示的，转向地址在相对于当前IP值的－128 ~ ＋127字节范围之内。
### 为零/相等时循环 LOOPZ/LOOPE (loop while nonzero or equal)
指令的汇编格式：LOOPNZ/LOOPNE label
指令的基本功能：
① (CX)←(CX)－1
② 若ZF=1且(CX)≠0，则(IP)←(IP)当前＋位移量，否则循环结束。
指令的特殊要求：循环指令都是短转移格式的指令，也就是说，位移量是用8位带符号数来表示的，转向地址在相对于当前IP值的－128 ~ ＋127字节范围之内。
### 不为零/不相等时循环 LOOPNZ/LOOPNE (loop while nonzero or not equal)
指令的汇编格式：LOOPNZ/LOOPNE label
指令的基本功能：
① (CX)←(CX)－1  
② 若ZF=0且(CX)≠0，则(IP)←(IP)当前＋位移量，否则循环结束。
指令的特殊要求：循环指令都是短转移格式的指令，也就是说，位移量是用8位带符号数来表示的，转向地址在相对于当前IP值的－128 ~ ＋127字节范围之内。
## 子程序调用
###段内直接近调用 CALL SUBROUT
指令的基本功能：
(SP)<-(SP)-2
((SP)+1,(sp))<-(IP)
(IP)<-(IP)+16位位移量
###段内间接近调用 CALL DESTIN
指令的基本功能：
(SP)<-(SP)-2
((SP)+1,(SP))<-(IP)
(IP)<-(EA)
### 段间直接调用 CALL FAR PTR SUBROUT
指令的基本功能：(SP)<-(SP)-2,((SP))<-(CS)当前
(SP)<-(SP)-2,((SP))<-(IP)当前
(IP)<-偏移地址(在指令的第2、3个字节)
(CS)<-段地址(在指令的第4、5个字节)
## 返回指令
### 段内返回(近返回) RET
指令的基本功能：(IP)<-((SP)+1,(SP))
(SP)<-(SP)+2
### 段间返回(远返回) RET
指令的基本功能：(IP)<-((SP)),(SP)<-(SP)+2
(CS)<-((SP)),(SP)<-(SP)+2
### 带立即数返回 RET N
执行操作：
① 返回地址出栈（操作同段内或段间返回）
② 修改堆栈指针：(SP) ← (SP)＋N

## 中断及中断返回指令
### INT n 中断指令（interrupt），n为中断类型号
　
```
执行操作：
① 入栈保存FLAGS：(SP) ← (SP)－2，((SP)) ← (FLAGS)
② 入栈保存返回地址：(SP) ← (SP)－2，((SP)) ← (CS)
　　　　　　　　　　(SP) ← (SP)－2，((SP)) ← (IP)
③ 转中断处理程序：(IP) ← (n×4)
　　　　　　　　　(CS) ← (n×4＋2)
```

### IRET 中断返回指令（return from interrupt）
``` 
　执行操作：
　① 返回地址出栈：(IP) ← ((SP))，(SP) ← (SP)＋2
　　　　　　　　　(CS) ← ((SP))，(SP) ← (SP)＋2
　② FLAGS出栈：(FLAGS) ← ((SP))，(SP) ← (SP)＋2
```
　　
### INTO 溢出则中断（中断类型为4)

```
执行操作：
若OF=1（有溢出），则：
① 入栈保存FLAGS：(SP) ← (SP)－2，((SP)) ← (FLAGS)
② 入栈保存返回地址：(SP) ← (SP)－2，((SP)) ← (CS)
                    (SP) ← (SP)－2，((SP)) ← (IP)
③ 转中断处理程序：(IP) ← (4×4)= (10H)
         　　　　 　　　 (CS) ← (4×4＋2)= (12H)
```
